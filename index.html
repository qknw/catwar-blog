<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Редактор блога</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>

    <div class="editor-container">
        <div class="toolbar">
             <button class="bold">B</button><button class="italic">I</button><button class="underline">U</button><button class="strike">S</button><button>Ō</button><button>center</button><button>right</button><button>justify</button><button>url</button><button>img</button><button>color</button><button>bgr</button><button>bgrf</button><button>size</button><button>font</button><button>hr</button><button>br</button><button>header</button><button>block</button><button>table</button><button>tr</button><button>td</button><button>ol</button><button>ul</button><button>li</button><button>audio</button><button>video</button><button>div</button><button>divr</button><button>code</button><button>pad</button>
        </div>

        <input type="text" class="input-field" id="blog-title" placeholder="Название блога">

        <textarea id="bbcode-input" class="textarea-field" placeholder="Текст"></textarea>

        <div class="actions">
              <button id="theme-toggle" class="action-button" type="button">Тёмная тема</button>
              <div style="flex-grow: 1;"></div>
              <button id="preview-button" class="action-button" type="button">Предпросмотр</button>
              <button id="save-button" class="action-button" type="button">Сохранить</button>
        </div>
    </div>

    <div id="preview-container" class="preview-area" style="display: none;">
        <h3 id="preview-title"></h3>
        <div id="preview-content"></div>
    </div>

    <script>
        function bbcodeToHtml(str) {
            str = str.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');

            // Normalise newlines for downstream handling
            str = str.replace(/\r\n?/g, '\n');

            const formatPaddingValue = (rawValue) => {
                if (!rawValue) {
                    return '0';
                }

                const parts = rawValue.trim().split(/\s+/).filter(Boolean);
                if (parts.length === 0) {
                    return '0';
                }

                return parts.map((part) => {
                    if (/^[+-]?(?:\d+(?:\.\d+)?|\.\d+)$/.test(part)) {
                        return Number(part) === 0 ? '0' : `${part}px`;
                    }
                    return part;
                }).join(' ');
            };

            const tagMap = {
                'b': { tag: 'b' }, 'i': { tag: 'i' }, 'u': { tag: 'u' }, 's': { tag: 's' },
                'o': { tag: 'span', style: 'text-decoration: overline' },
                'center': { tag: 'div', align: 'center' },
                'right': { tag: 'div', align: 'right' },
                'justify': { tag: 'div', style: 'text-align: justify' },
                'hr': { tag: 'hr', selfClosing: true },
                'table': {
                    tag: 'table',
                    paramFunc: (p) => p === '=0' ? {} : (p ? {'data-cell-color': p.substring(1)} : {})
                },
                'tr': { tag: 'tr' },
                'td': { tag: 'td' },
                'header': {
                    tag: 'a',
                    class: 'headers',
                    href: '#',
                    paramFunc: (p) => {
                        const id = p ? p.substring(1) : '';
                        return { 'data-menu': id, 'data-id': id };
                    }
                },
                'block': {
                    tag: 'div',
                    class: 'blocks',
                    style: 'display: none;',
                    paramFunc: (p) => {
                        const id = p ? p.substring(1) : '';
                        return { 'data-menu': id, 'data-id': id };
                    }
                },
                'color': { tag: 'span', style: 'color: {param}', param: true },
                'font': { tag: 'span', style: 'font-family: {param}', param: true },
                'size': { tag: 'span', style: 'font-size: {param}pt', param: true },
                'bgr': { tag: 'span', style: 'background-color: {param}', param: true },
                'bgrf': { tag: 'div', style: 'background-color: {param}', param: true },
                'pad': { tag: 'div', style: 'padding: {param}', param: true, paramFormatter: formatPaddingValue },
                'div': { tag: 'div', style: 'background-image: url(\'{param}\')', param: true },
                'divr': { tag: 'div', style: 'background-image: url(\'{param}\')', param: true }, // Same as div based on target
                'img': {
                    tag: 'img',
                    selfClosing: true,
                    noParamFunc: (content) => ({ 'src': content }),
                },
                'url': {
                    tag: 'a',
                    param: true,
                    paramFunc: (p) => ({ 'href': p ? p.substring(1) : '#', 'target': '_blank' }),
                    noParamFunc: (content) => ({ 'href': content, 'target': '_blank' })
                },
                'br': { tag: 'br', selfClosing: true },
                'ol': { tag: 'ol' },
                'ul': { tag: 'ul' },
                'li': { tag: 'li' },
                'audio': {
                    tag: 'audio',
                    selfClosing: true,
                    noParamFunc: (content) => ({ 'src': content.trim(), 'controls': '' })
                },
                'video': {
                    tag: 'video',
                    selfClosing: true,
                    noParamFunc: (content) => ({ 'src': content.trim(), 'controls': '' })
                },
                'code': { tag: 'pre' }
            };

            const process = (text) => {
                const regex = /\[(\/)?([a-zA-Z0-9]+)(=[^\]]+)?\]|([^\[]+|\[)/g;
                let match;
                let result = '';
                const stack = [];

                const appendContent = (value) => {
                    if (!value) {
                        return '';
                    }
                    return value.replace(/\n/g, '<br>');
                };

                while ((match = regex.exec(text)) !== null) {
                    let [fullMatch, isClosing, tagName, param, content] = match;

                    if (content) {
                        result += appendContent(content);
                        continue;
                    }

                    const cleanTagName = tagName.trim().toLowerCase();
                    const tagDef = tagMap[cleanTagName];
                    if (!tagDef) {
                        result += fullMatch;
                        continue;
                    }

                    if (isClosing) {
                        if (stack.length > 0 && stack[stack.length - 1].toLowerCase() === cleanTagName) {
                            stack.pop();
                            result += `</${tagDef.tag}>`;
                        } else {
                            result += fullMatch;
                        }
                    } else {
                        let attrs = '';
                        if (tagDef.href) attrs += ` href="${tagDef.href}"`;
                        if (tagDef.class) attrs += ` class="${tagDef.class}"`;

                        let style = tagDef.style ? tagDef.style : '';

                        if (param) {
                            const pValue = param.substring(1);
                            if (tagDef.param && style) {
                                const formattedValue = typeof tagDef.paramFormatter === 'function'
                                    ? tagDef.paramFormatter(pValue)
                                    : pValue;
                                style = style.replace('{param}', formattedValue);
                            }
                             if(tagDef.paramFunc) {
                                 const pAttrs = tagDef.paramFunc(param);
                                 for(const key in pAttrs) {
                                     attrs += ` ${key}="${pAttrs[key]}"`;
                                 }
                             }
                        }

                        if(tagDef.align) attrs += ` align="${tagDef.align}"`;
                        if (style) attrs += ` style="${style}"`;

                        if (tagDef.selfClosing) {
                            let innerContentMatch = text.substring(regex.lastIndex).match(/[^\[]*/);
                            let innerContent = '';
                            if(innerContentMatch) {
                                innerContent = innerContentMatch[0];
                                regex.lastIndex += innerContent.length;
                            }

                            const nextClosingTagMatch = text.substring(regex.lastIndex).match(/\[\/([^\]]+)\]/);

                            if(nextClosingTagMatch && nextClosingTagMatch[1].trim().toLowerCase() === cleanTagName) {
                                if(tagDef.noParamFunc) {
                                     const pAttrs = tagDef.noParamFunc(innerContent.trim());
                                     for(const key in pAttrs) {
                                         attrs += ` ${key}="${pAttrs[key]}"`;
                                     }
                                }
                                result += `<${tagDef.tag}${attrs}>`;
                                regex.lastIndex += nextClosingTagMatch[0].length;
                            } else {
                                result += `<${tagDef.tag}${attrs}>`;
                            }

                        } else {
                            result += `<${tagDef.tag}${attrs}>`;
                            stack.push(cleanTagName);
                        }
                    }
                }
                while(stack.length > 0) {
                    const openTag = stack.pop();
                    result += `</${tagMap[openTag.toLowerCase()].tag}>`;
                }

                result = result
                    .replace(/(<br>){2,}(?=<table\b)/gi, '<br><br>')
                    .replace(/(<br>)+(?=<\/?(?:thead|tbody|tfoot|tr|td)\b)/gi, '')
                    .replace(/(<br>)+(?=<\/table>)/gi, '');

                return result;
            };

            return process(str);
        }

        const previewButton = document.getElementById('preview-button');
        const saveButton = document.getElementById('save-button'); // New button
        const themeToggle = document.getElementById('theme-toggle');
        const bbcodeInput = document.getElementById('bbcode-input');
        const blogTitleInput = document.getElementById('blog-title');
        const previewContainer = document.getElementById('preview-container');
        const previewContent = document.getElementById('preview-content');
        const previewTitle = document.getElementById('preview-title');
        const THEME_STORAGE_KEY = 'editor-theme';

        function getStoredTheme() {
            try {
                return localStorage.getItem(THEME_STORAGE_KEY);
            } catch (error) {
                return null;
            }
        }

        function storeTheme(theme) {
            try {
                localStorage.setItem(THEME_STORAGE_KEY, theme);
            } catch (error) {
                /* Ignore storage errors to keep toggle functional */
            }
        }

        function applyTheme(theme) {
            document.body.classList.toggle('theme-dark', theme === 'dark');
            themeToggle.textContent = theme === 'dark' ? 'Светлая тема' : 'Тёмная тема';
            themeToggle.setAttribute('aria-pressed', theme === 'dark');
            storeTheme(theme);
        }

        const savedTheme = getStoredTheme();
        if (savedTheme === 'dark') {
            applyTheme('dark');
        } else {
            applyTheme('light');
        }

        themeToggle.addEventListener('click', () => {
            const nextTheme = document.body.classList.contains('theme-dark') ? 'light' : 'dark';
            applyTheme(nextTheme);
        });

        previewButton.addEventListener('click', () => {
            const bbcodeText = bbcodeInput.value;
            const titleText = blogTitleInput.value || "Предпросмотр";

            const html = bbcodeToHtml(bbcodeText);

            previewTitle.textContent = titleText;
            previewContent.innerHTML = `<div class="parsed">${html}</div>`;

            previewContainer.style.display = 'block';

            // Post-process table colors
             previewContent.querySelectorAll('table[data-cell-color]').forEach(table => {
                 const color = table.dataset.cellColor;
                 table.querySelectorAll('td').forEach(cell => {
                     cell.style.backgroundColor = color;
                 });
             });
        });

        // --- UPDATED SAVE BUTTON FUNCTIONALITY ---
        saveButton.addEventListener('click', () => {
            // Get the raw BBCode directly from the textarea
            const content = bbcodeInput.value;
            const title = blogTitleInput.value || "Без названия";

            // Check if there is content to save
            if (content.trim() === '' && title.trim() === 'Без названия') {
                console.log("Нет содержимого для сохранения.");
                return;
            }

            // Combine title and content for the file
            const fileContent = `Название: ${title}\n\n---\n\n${content}`;

            // Create a Blob
            const blob = new Blob([fileContent], { type: 'text/plain;charset=utf-8' });

            // Create a temporary link to trigger the download
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);

            // Generate a filename from the blog title
            const filename = (blogTitleInput.value.trim().replace(/[^a-z0-9]/gi, '_').toLowerCase() || 'blog_post') + '.txt';
            link.download = filename;

            // Append to body, click, and remove
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        previewContent.addEventListener('click', (event) => {
            const target = event.target.closest('a.headers');
            if (target) {
                event.preventDefault();
                const id = target.dataset.id;
                if (id) {
                    const blocks = previewContent.querySelectorAll(`.blocks[data-id="${id}"]`);
                    blocks.forEach(block => {
                        block.style.display = block.style.display === 'none' ? 'block' : 'none';
                    });
                }
            }
        });

        // --- КОД ДЛЯ ПАНЕЛИ ИНСТРУМЕНТОВ ---
        const toolbar = document.querySelector('.toolbar');
        toolbar.addEventListener('click', (event) => {
            const target = event.target;
            if (target.tagName !== 'BUTTON') {
                return;
            }

            const command = target.textContent.trim();
            const bbcodeTextarea = document.getElementById('bbcode-input');

            const simpleTags = {
                'B': { start: '[b]', end: '[/b]' },
                'I': { start: '[i]', end: '[/i]' },
                'U': { start: '[u]', end: '[/u]' },
                'S': { start: '[s]', end: '[/s]' },
                'Ō': { start: '[o]', end: '[/o]' },
                'center': { start: '[center]', end: '[/center]' },
                'right': { start: '[right]', end: '[/right]' },
                'justify': { start: '[justify]', end: '[/justify]' },
                'hr': { start: '[hr]', end: '' },
                'br': { start: '[br]', end: '' },
                'table': { start: '[table]\n', end: '\n[/table]' },
                'tr': { start: '\t[tr]\n', end: '\n\t[/tr]' },
                'td': { start: '\t\t[td]', end: '[/td]\n' },
                'ol': { start: '[ol]\n', end: '\n[/ol]' },
                'ul': { start: '[ul]\n', end: '\n[/ul]' },
                'li': { start: '\t[li]', end: '[/li]\n' },
                'audio': { start: '[audio]', end: '[/audio]' },
                'video': { start: '[video]', end: '[/video]' },
                'code': { start: '[code]', end: '[/code]' },
                'img': { start: '[img]', end: '[/img]' }
            };

            const promptTags = {
                'url': { prompt: 'Введите URL', default: 'https://' },
                'color': { prompt: 'Введите цвет (например, red или #FF0000)', default: 'red' },
                'bgr': { prompt: 'Введите цвет фона', default: '#FFFF00' },
                'bgrf': { prompt: 'Введите цвет фона для блока', default: '#FFFF00' },
                'size': { prompt: 'Введите размер шрифта (число)', default: '12' },
                'font': { prompt: 'Введите название шрифта', default: 'Arial' },
                'header': { prompt: 'Введите ID заголовка', default: '1' },
                'block': { prompt: 'Введите ID блока', default: '1' },
                'div': { prompt: 'Введите URL изображения для фона', default: 'https://' },
                'divr': { prompt: 'Введите URL изображения для фона (повторяющегося)', default: 'https://' },
                'pad': { prompt: 'Введите отступ в пикселях (число)', default: '10' }
            };

            function insertTags(startTag, endTag = '') {
                const startPos = bbcodeTextarea.selectionStart;
                const endPos = bbcodeTextarea.selectionEnd;
                const selectedText = bbcodeTextarea.value.substring(startPos, endPos);

                const newText = `${startTag}${selectedText}${endTag}`;

                bbcodeTextarea.setRangeText(newText, startPos, endPos, 'end');

                if (selectedText.length === 0) {
                     bbcodeTextarea.selectionStart = bbcodeTextarea.selectionEnd = startPos + startTag.length;
                } else {
                     bbcodeTextarea.selectionStart = startPos + startTag.length;
                     bbcodeTextarea.selectionEnd = startPos + startTag.length + selectedText.length;
                }

                bbcodeTextarea.focus();
            }

            if (simpleTags[command]) {
                const { start, end } = simpleTags[command];
                insertTags(start, end);
            } else if (promptTags[command]) {
                const { prompt: promptText, default: defaultValue } = promptTags[command];
                const param = prompt(promptText, defaultValue);
                if (param !== null && param.trim() !== '') {
                    const startTag = `[${command.toLowerCase()}=${param}]`;
                    const endTag = `[/${command.toLowerCase()}]`;
                    insertTags(startTag, endTag);
                }
            }
        });
    </script>

</body>
</html>
